{"ast":null,"code":"import { _ as _createClass, a as _classCallCheck, f as _slicedToArray } from '../_rollupPluginBabelHelpers-b054ecd2.js';\nimport ChangeDetails from '../core/change-details.js';\nimport ContinuousTailDetails from '../core/continuous-tail-details.js';\nimport { isString, normalizePrepare, forceDirection, DIRECTION } from '../core/utils.js';\nimport IMask from '../core/holder.js';\n/** Supported mask type */\n\n/** Provides common masking stuff */\n\nvar Masked = /*#__PURE__*/function () {\n  // $Shape<MaskedOptions>; TODO after fix https://github.com/facebook/flow/issues/4773\n\n  /** @type {Mask} */\n\n  /** */\n  // $FlowFixMe no ideas\n\n  /** Transforms value before mask processing */\n\n  /** Validates if value is acceptable */\n\n  /** Does additional processing in the end of editing */\n\n  /** Format typed value to string */\n\n  /** Parse strgin to get typed value */\n\n  /** Enable characters overwriting */\n\n  /** */\n\n  /** */\n  function Masked(opts) {\n    _classCallCheck(this, Masked);\n\n    this._value = '';\n\n    this._update(Object.assign({}, Masked.DEFAULTS, opts));\n\n    this.isInitialized = true;\n  }\n  /** Sets and applies new options */\n\n\n  _createClass(Masked, [{\n    key: \"updateOptions\",\n    value: function updateOptions(opts) {\n      if (!Object.keys(opts).length) return; // $FlowFixMe\n\n      this.withValueRefresh(this._update.bind(this, opts));\n    }\n    /**\n      Sets new options\n      @protected\n    */\n\n  }, {\n    key: \"_update\",\n    value: function _update(opts) {\n      Object.assign(this, opts);\n    }\n    /** Mask state */\n\n  }, {\n    key: \"state\",\n    get: function get() {\n      return {\n        _value: this.value\n      };\n    },\n    set: function set(state) {\n      this._value = state._value;\n    }\n    /** Resets value */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._value = '';\n    }\n    /** */\n\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this._value;\n    },\n    set: function set(value) {\n      this.resolve(value);\n    }\n    /** Resolve new value */\n\n  }, {\n    key: \"resolve\",\n    value: function resolve(value) {\n      this.reset();\n      this.append(value, {\n        input: true\n      }, '');\n      this.doCommit();\n      return this.value;\n    }\n    /** */\n\n  }, {\n    key: \"unmaskedValue\",\n    get: function get() {\n      return this.value;\n    },\n    set: function set(value) {\n      this.reset();\n      this.append(value, {}, '');\n      this.doCommit();\n    }\n    /** */\n\n  }, {\n    key: \"typedValue\",\n    get: function get() {\n      return this.doParse(this.value);\n    },\n    set: function set(value) {\n      this.value = this.doFormat(value);\n    }\n    /** Value that includes raw user input */\n\n  }, {\n    key: \"rawInputValue\",\n    get: function get() {\n      return this.extractInput(0, this.value.length, {\n        raw: true\n      });\n    },\n    set: function set(value) {\n      this.reset();\n      this.append(value, {\n        raw: true\n      }, '');\n      this.doCommit();\n    }\n    /** */\n\n  }, {\n    key: \"isComplete\",\n    get: function get() {\n      return true;\n    }\n    /** */\n\n  }, {\n    key: \"isFilled\",\n    get: function get() {\n      return this.isComplete;\n    }\n    /** Finds nearest input position in direction */\n\n  }, {\n    key: \"nearestInputPos\",\n    value: function nearestInputPos(cursorPos, direction) {\n      return cursorPos;\n    }\n    /** Extracts value in range considering flags */\n\n  }, {\n    key: \"extractInput\",\n    value: function extractInput() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      return this.value.slice(fromPos, toPos);\n    }\n    /** Extracts tail in range */\n\n  }, {\n    key: \"extractTail\",\n    value: function extractTail() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      return new ContinuousTailDetails(this.extractInput(fromPos, toPos), fromPos);\n    }\n    /** Appends tail */\n    // $FlowFixMe no ideas\n\n  }, {\n    key: \"appendTail\",\n    value: function appendTail(tail) {\n      if (isString(tail)) tail = new ContinuousTailDetails(String(tail));\n      return tail.appendTo(this);\n    }\n    /** Appends char */\n\n  }, {\n    key: \"_appendCharRaw\",\n    value: function _appendCharRaw(ch) {\n      if (!ch) return new ChangeDetails();\n      this._value += ch;\n      return new ChangeDetails({\n        inserted: ch,\n        rawInserted: ch\n      });\n    }\n    /** Appends char */\n\n  }, {\n    key: \"_appendChar\",\n    value: function _appendChar(ch) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var checkTail = arguments.length > 2 ? arguments[2] : undefined;\n      var consistentState = this.state;\n      var details;\n\n      var _normalizePrepare = normalizePrepare(this.doPrepare(ch, flags));\n\n      var _normalizePrepare2 = _slicedToArray(_normalizePrepare, 2);\n\n      ch = _normalizePrepare2[0];\n      details = _normalizePrepare2[1];\n      details = details.aggregate(this._appendCharRaw(ch, flags));\n\n      if (details.inserted) {\n        var consistentTail;\n        var appended = this.doValidate(flags) !== false;\n\n        if (appended && checkTail != null) {\n          // validation ok, check tail\n          var beforeTailState = this.state;\n\n          if (this.overwrite === true) {\n            consistentTail = checkTail.state;\n            checkTail.unshift(this.value.length);\n          }\n\n          var tailDetails = this.appendTail(checkTail);\n          appended = tailDetails.rawInserted === checkTail.toString(); // not ok, try shift\n\n          if (!(appended && tailDetails.inserted) && this.overwrite === 'shift') {\n            this.state = beforeTailState;\n            consistentTail = checkTail.state;\n            checkTail.shift();\n            tailDetails = this.appendTail(checkTail);\n            appended = tailDetails.rawInserted === checkTail.toString();\n          } // if ok, rollback state after tail\n\n\n          if (appended && tailDetails.inserted) this.state = beforeTailState;\n        } // revert all if something went wrong\n\n\n        if (!appended) {\n          details = new ChangeDetails();\n          this.state = consistentState;\n          if (checkTail && consistentTail) checkTail.state = consistentTail;\n        }\n      }\n\n      return details;\n    }\n    /** Appends optional placeholder at end */\n\n  }, {\n    key: \"_appendPlaceholder\",\n    value: function _appendPlaceholder() {\n      return new ChangeDetails();\n    }\n    /** Appends optional eager placeholder at end */\n\n  }, {\n    key: \"_appendEager\",\n    value: function _appendEager() {\n      return new ChangeDetails();\n    }\n    /** Appends symbols considering flags */\n    // $FlowFixMe no ideas\n\n  }, {\n    key: \"append\",\n    value: function append(str, flags, tail) {\n      if (!isString(str)) throw new Error('value should be string');\n      var details = new ChangeDetails();\n      var checkTail = isString(tail) ? new ContinuousTailDetails(String(tail)) : tail;\n      if (flags && flags.tail) flags._beforeTailState = this.state;\n\n      for (var ci = 0; ci < str.length; ++ci) {\n        details.aggregate(this._appendChar(str[ci], flags, checkTail));\n      } // append tail but aggregate only tailShift\n\n\n      if (checkTail != null) {\n        details.tailShift += this.appendTail(checkTail).tailShift; // TODO it's a good idea to clear state after appending ends\n        // but it causes bugs when one append calls another (when dynamic dispatch set rawInputValue)\n        // this._resetBeforeTailState();\n      }\n\n      if (this.eager && flags !== null && flags !== void 0 && flags.input && str) {\n        details.aggregate(this._appendEager());\n      }\n\n      return details;\n    }\n    /** */\n\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      this._value = this.value.slice(0, fromPos) + this.value.slice(toPos);\n      return new ChangeDetails();\n    }\n    /** Calls function and reapplies current value */\n\n  }, {\n    key: \"withValueRefresh\",\n    value: function withValueRefresh(fn) {\n      if (this._refreshing || !this.isInitialized) return fn();\n      this._refreshing = true;\n      var rawInput = this.rawInputValue;\n      var value = this.value;\n      var ret = fn();\n      this.rawInputValue = rawInput; // append lost trailing chars at end\n\n      if (this.value && this.value !== value && value.indexOf(this.value) === 0) {\n        this.append(value.slice(this.value.length), {}, '');\n      }\n\n      delete this._refreshing;\n      return ret;\n    }\n    /** */\n\n  }, {\n    key: \"runIsolated\",\n    value: function runIsolated(fn) {\n      if (this._isolated || !this.isInitialized) return fn(this);\n      this._isolated = true;\n      var state = this.state;\n      var ret = fn(this);\n      this.state = state;\n      delete this._isolated;\n      return ret;\n    }\n    /**\n      Prepares string before mask processing\n      @protected\n    */\n\n  }, {\n    key: \"doPrepare\",\n    value: function doPrepare(str) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.prepare ? this.prepare(str, this, flags) : str;\n    }\n    /**\n      Validates if value is acceptable\n      @protected\n    */\n\n  }, {\n    key: \"doValidate\",\n    value: function doValidate(flags) {\n      return (!this.validate || this.validate(this.value, this, flags)) && (!this.parent || this.parent.doValidate(flags));\n    }\n    /**\n      Does additional processing in the end of editing\n      @protected\n    */\n\n  }, {\n    key: \"doCommit\",\n    value: function doCommit() {\n      if (this.commit) this.commit(this.value, this);\n    }\n    /** */\n\n  }, {\n    key: \"doFormat\",\n    value: function doFormat(value) {\n      return this.format ? this.format(value, this) : value;\n    }\n    /** */\n\n  }, {\n    key: \"doParse\",\n    value: function doParse(str) {\n      return this.parse ? this.parse(str, this) : str;\n    }\n    /** */\n\n  }, {\n    key: \"splice\",\n    value: function splice(start, deleteCount, inserted, removeDirection) {\n      var tailPos = start + deleteCount;\n      var tail = this.extractTail(tailPos);\n      var oldRawValue;\n\n      if (this.eager) {\n        removeDirection = forceDirection(removeDirection);\n        oldRawValue = this.extractInput(0, tailPos, {\n          raw: true\n        });\n      }\n\n      var startChangePos = this.nearestInputPos(start, deleteCount > 1 && start !== 0 && !this.eager ? DIRECTION.NONE : removeDirection);\n      var details = new ChangeDetails({\n        tailShift: startChangePos - start // adjust tailShift if start was aligned\n\n      }).aggregate(this.remove(startChangePos));\n\n      if (this.eager && removeDirection !== DIRECTION.NONE && oldRawValue === this.rawInputValue) {\n        if (removeDirection === DIRECTION.FORCE_LEFT) {\n          var valLength;\n\n          while (oldRawValue === this.rawInputValue && (valLength = this.value.length)) {\n            details.aggregate(new ChangeDetails({\n              tailShift: -1\n            })).aggregate(this.remove(valLength - 1));\n          }\n        } else if (removeDirection === DIRECTION.FORCE_RIGHT) {\n          tail.unshift();\n        }\n      }\n\n      return details.aggregate(this.append(inserted, {\n        input: true\n      }, tail));\n    }\n  }, {\n    key: \"maskEquals\",\n    value: function maskEquals(mask) {\n      return this.mask === mask;\n    }\n  }]);\n\n  return Masked;\n}();\n\nMasked.DEFAULTS = {\n  format: function format(v) {\n    return v;\n  },\n  parse: function parse(v) {\n    return v;\n  }\n};\nIMask.Masked = Masked;\nexport { Masked as default };","map":{"version":3,"names":["_","_createClass","a","_classCallCheck","f","_slicedToArray","ChangeDetails","ContinuousTailDetails","isString","normalizePrepare","forceDirection","DIRECTION","IMask","Masked","opts","_value","_update","Object","assign","DEFAULTS","isInitialized","key","value","updateOptions","keys","length","withValueRefresh","bind","get","set","state","reset","resolve","append","input","doCommit","doParse","doFormat","extractInput","raw","isComplete","nearestInputPos","cursorPos","direction","fromPos","arguments","undefined","toPos","slice","extractTail","appendTail","tail","String","appendTo","_appendCharRaw","ch","inserted","rawInserted","_appendChar","flags","checkTail","consistentState","details","_normalizePrepare","doPrepare","_normalizePrepare2","aggregate","consistentTail","appended","doValidate","beforeTailState","overwrite","unshift","tailDetails","toString","shift","_appendPlaceholder","_appendEager","str","Error","_beforeTailState","ci","tailShift","eager","remove","fn","_refreshing","rawInput","rawInputValue","ret","indexOf","runIsolated","_isolated","prepare","validate","parent","commit","format","parse","splice","start","deleteCount","removeDirection","tailPos","oldRawValue","startChangePos","NONE","FORCE_LEFT","valLength","FORCE_RIGHT","maskEquals","mask","v","default"],"sources":["/home/suraphelm/Projects/demo/Myproject/react/starter/01-starting-setup/node_modules/imask/esm/masked/base.js"],"sourcesContent":["import { _ as _createClass, a as _classCallCheck, f as _slicedToArray } from '../_rollupPluginBabelHelpers-b054ecd2.js';\nimport ChangeDetails from '../core/change-details.js';\nimport ContinuousTailDetails from '../core/continuous-tail-details.js';\nimport { isString, normalizePrepare, forceDirection, DIRECTION } from '../core/utils.js';\nimport IMask from '../core/holder.js';\n\n/** Supported mask type */\n\n/** Provides common masking stuff */\nvar Masked = /*#__PURE__*/function () {\n  // $Shape<MaskedOptions>; TODO after fix https://github.com/facebook/flow/issues/4773\n\n  /** @type {Mask} */\n\n  /** */\n  // $FlowFixMe no ideas\n\n  /** Transforms value before mask processing */\n\n  /** Validates if value is acceptable */\n\n  /** Does additional processing in the end of editing */\n\n  /** Format typed value to string */\n\n  /** Parse strgin to get typed value */\n\n  /** Enable characters overwriting */\n\n  /** */\n\n  /** */\n  function Masked(opts) {\n    _classCallCheck(this, Masked);\n\n    this._value = '';\n\n    this._update(Object.assign({}, Masked.DEFAULTS, opts));\n\n    this.isInitialized = true;\n  }\n  /** Sets and applies new options */\n\n\n  _createClass(Masked, [{\n    key: \"updateOptions\",\n    value: function updateOptions(opts) {\n      if (!Object.keys(opts).length) return; // $FlowFixMe\n\n      this.withValueRefresh(this._update.bind(this, opts));\n    }\n    /**\n      Sets new options\n      @protected\n    */\n\n  }, {\n    key: \"_update\",\n    value: function _update(opts) {\n      Object.assign(this, opts);\n    }\n    /** Mask state */\n\n  }, {\n    key: \"state\",\n    get: function get() {\n      return {\n        _value: this.value\n      };\n    },\n    set: function set(state) {\n      this._value = state._value;\n    }\n    /** Resets value */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._value = '';\n    }\n    /** */\n\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this._value;\n    },\n    set: function set(value) {\n      this.resolve(value);\n    }\n    /** Resolve new value */\n\n  }, {\n    key: \"resolve\",\n    value: function resolve(value) {\n      this.reset();\n      this.append(value, {\n        input: true\n      }, '');\n      this.doCommit();\n      return this.value;\n    }\n    /** */\n\n  }, {\n    key: \"unmaskedValue\",\n    get: function get() {\n      return this.value;\n    },\n    set: function set(value) {\n      this.reset();\n      this.append(value, {}, '');\n      this.doCommit();\n    }\n    /** */\n\n  }, {\n    key: \"typedValue\",\n    get: function get() {\n      return this.doParse(this.value);\n    },\n    set: function set(value) {\n      this.value = this.doFormat(value);\n    }\n    /** Value that includes raw user input */\n\n  }, {\n    key: \"rawInputValue\",\n    get: function get() {\n      return this.extractInput(0, this.value.length, {\n        raw: true\n      });\n    },\n    set: function set(value) {\n      this.reset();\n      this.append(value, {\n        raw: true\n      }, '');\n      this.doCommit();\n    }\n    /** */\n\n  }, {\n    key: \"isComplete\",\n    get: function get() {\n      return true;\n    }\n    /** */\n\n  }, {\n    key: \"isFilled\",\n    get: function get() {\n      return this.isComplete;\n    }\n    /** Finds nearest input position in direction */\n\n  }, {\n    key: \"nearestInputPos\",\n    value: function nearestInputPos(cursorPos, direction) {\n      return cursorPos;\n    }\n    /** Extracts value in range considering flags */\n\n  }, {\n    key: \"extractInput\",\n    value: function extractInput() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      return this.value.slice(fromPos, toPos);\n    }\n    /** Extracts tail in range */\n\n  }, {\n    key: \"extractTail\",\n    value: function extractTail() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      return new ContinuousTailDetails(this.extractInput(fromPos, toPos), fromPos);\n    }\n    /** Appends tail */\n    // $FlowFixMe no ideas\n\n  }, {\n    key: \"appendTail\",\n    value: function appendTail(tail) {\n      if (isString(tail)) tail = new ContinuousTailDetails(String(tail));\n      return tail.appendTo(this);\n    }\n    /** Appends char */\n\n  }, {\n    key: \"_appendCharRaw\",\n    value: function _appendCharRaw(ch) {\n      if (!ch) return new ChangeDetails();\n      this._value += ch;\n      return new ChangeDetails({\n        inserted: ch,\n        rawInserted: ch\n      });\n    }\n    /** Appends char */\n\n  }, {\n    key: \"_appendChar\",\n    value: function _appendChar(ch) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var checkTail = arguments.length > 2 ? arguments[2] : undefined;\n      var consistentState = this.state;\n      var details;\n\n      var _normalizePrepare = normalizePrepare(this.doPrepare(ch, flags));\n\n      var _normalizePrepare2 = _slicedToArray(_normalizePrepare, 2);\n\n      ch = _normalizePrepare2[0];\n      details = _normalizePrepare2[1];\n      details = details.aggregate(this._appendCharRaw(ch, flags));\n\n      if (details.inserted) {\n        var consistentTail;\n        var appended = this.doValidate(flags) !== false;\n\n        if (appended && checkTail != null) {\n          // validation ok, check tail\n          var beforeTailState = this.state;\n\n          if (this.overwrite === true) {\n            consistentTail = checkTail.state;\n            checkTail.unshift(this.value.length);\n          }\n\n          var tailDetails = this.appendTail(checkTail);\n          appended = tailDetails.rawInserted === checkTail.toString(); // not ok, try shift\n\n          if (!(appended && tailDetails.inserted) && this.overwrite === 'shift') {\n            this.state = beforeTailState;\n            consistentTail = checkTail.state;\n            checkTail.shift();\n            tailDetails = this.appendTail(checkTail);\n            appended = tailDetails.rawInserted === checkTail.toString();\n          } // if ok, rollback state after tail\n\n\n          if (appended && tailDetails.inserted) this.state = beforeTailState;\n        } // revert all if something went wrong\n\n\n        if (!appended) {\n          details = new ChangeDetails();\n          this.state = consistentState;\n          if (checkTail && consistentTail) checkTail.state = consistentTail;\n        }\n      }\n\n      return details;\n    }\n    /** Appends optional placeholder at end */\n\n  }, {\n    key: \"_appendPlaceholder\",\n    value: function _appendPlaceholder() {\n      return new ChangeDetails();\n    }\n    /** Appends optional eager placeholder at end */\n\n  }, {\n    key: \"_appendEager\",\n    value: function _appendEager() {\n      return new ChangeDetails();\n    }\n    /** Appends symbols considering flags */\n    // $FlowFixMe no ideas\n\n  }, {\n    key: \"append\",\n    value: function append(str, flags, tail) {\n      if (!isString(str)) throw new Error('value should be string');\n      var details = new ChangeDetails();\n      var checkTail = isString(tail) ? new ContinuousTailDetails(String(tail)) : tail;\n      if (flags && flags.tail) flags._beforeTailState = this.state;\n\n      for (var ci = 0; ci < str.length; ++ci) {\n        details.aggregate(this._appendChar(str[ci], flags, checkTail));\n      } // append tail but aggregate only tailShift\n\n\n      if (checkTail != null) {\n        details.tailShift += this.appendTail(checkTail).tailShift; // TODO it's a good idea to clear state after appending ends\n        // but it causes bugs when one append calls another (when dynamic dispatch set rawInputValue)\n        // this._resetBeforeTailState();\n      }\n\n      if (this.eager && flags !== null && flags !== void 0 && flags.input && str) {\n        details.aggregate(this._appendEager());\n      }\n\n      return details;\n    }\n    /** */\n\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      this._value = this.value.slice(0, fromPos) + this.value.slice(toPos);\n      return new ChangeDetails();\n    }\n    /** Calls function and reapplies current value */\n\n  }, {\n    key: \"withValueRefresh\",\n    value: function withValueRefresh(fn) {\n      if (this._refreshing || !this.isInitialized) return fn();\n      this._refreshing = true;\n      var rawInput = this.rawInputValue;\n      var value = this.value;\n      var ret = fn();\n      this.rawInputValue = rawInput; // append lost trailing chars at end\n\n      if (this.value && this.value !== value && value.indexOf(this.value) === 0) {\n        this.append(value.slice(this.value.length), {}, '');\n      }\n\n      delete this._refreshing;\n      return ret;\n    }\n    /** */\n\n  }, {\n    key: \"runIsolated\",\n    value: function runIsolated(fn) {\n      if (this._isolated || !this.isInitialized) return fn(this);\n      this._isolated = true;\n      var state = this.state;\n      var ret = fn(this);\n      this.state = state;\n      delete this._isolated;\n      return ret;\n    }\n    /**\n      Prepares string before mask processing\n      @protected\n    */\n\n  }, {\n    key: \"doPrepare\",\n    value: function doPrepare(str) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.prepare ? this.prepare(str, this, flags) : str;\n    }\n    /**\n      Validates if value is acceptable\n      @protected\n    */\n\n  }, {\n    key: \"doValidate\",\n    value: function doValidate(flags) {\n      return (!this.validate || this.validate(this.value, this, flags)) && (!this.parent || this.parent.doValidate(flags));\n    }\n    /**\n      Does additional processing in the end of editing\n      @protected\n    */\n\n  }, {\n    key: \"doCommit\",\n    value: function doCommit() {\n      if (this.commit) this.commit(this.value, this);\n    }\n    /** */\n\n  }, {\n    key: \"doFormat\",\n    value: function doFormat(value) {\n      return this.format ? this.format(value, this) : value;\n    }\n    /** */\n\n  }, {\n    key: \"doParse\",\n    value: function doParse(str) {\n      return this.parse ? this.parse(str, this) : str;\n    }\n    /** */\n\n  }, {\n    key: \"splice\",\n    value: function splice(start, deleteCount, inserted, removeDirection) {\n      var tailPos = start + deleteCount;\n      var tail = this.extractTail(tailPos);\n      var oldRawValue;\n\n      if (this.eager) {\n        removeDirection = forceDirection(removeDirection);\n        oldRawValue = this.extractInput(0, tailPos, {\n          raw: true\n        });\n      }\n\n      var startChangePos = this.nearestInputPos(start, deleteCount > 1 && start !== 0 && !this.eager ? DIRECTION.NONE : removeDirection);\n      var details = new ChangeDetails({\n        tailShift: startChangePos - start // adjust tailShift if start was aligned\n\n      }).aggregate(this.remove(startChangePos));\n\n      if (this.eager && removeDirection !== DIRECTION.NONE && oldRawValue === this.rawInputValue) {\n        if (removeDirection === DIRECTION.FORCE_LEFT) {\n          var valLength;\n\n          while (oldRawValue === this.rawInputValue && (valLength = this.value.length)) {\n            details.aggregate(new ChangeDetails({\n              tailShift: -1\n            })).aggregate(this.remove(valLength - 1));\n          }\n        } else if (removeDirection === DIRECTION.FORCE_RIGHT) {\n          tail.unshift();\n        }\n      }\n\n      return details.aggregate(this.append(inserted, {\n        input: true\n      }, tail));\n    }\n  }, {\n    key: \"maskEquals\",\n    value: function maskEquals(mask) {\n      return this.mask === mask;\n    }\n  }]);\n\n  return Masked;\n}();\nMasked.DEFAULTS = {\n  format: function format(v) {\n    return v;\n  },\n  parse: function parse(v) {\n    return v;\n  }\n};\nIMask.Masked = Masked;\n\nexport { Masked as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}