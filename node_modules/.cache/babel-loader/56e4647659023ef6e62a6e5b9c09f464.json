{"ast":null,"code":"import { _ as _createClass, a as _classCallCheck, b as _objectWithoutProperties } from '../../_rollupPluginBabelHelpers-b054ecd2.js';\nimport ChangeDetails from '../../core/change-details.js';\nimport { isString } from '../../core/utils.js';\nimport ContinuousTailDetails from '../../core/continuous-tail-details.js';\nimport IMask from '../../core/holder.js';\nvar _excluded = [\"chunks\"];\n\nvar ChunksTailDetails = /*#__PURE__*/function () {\n  /** */\n  function ChunksTailDetails() {\n    var chunks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    _classCallCheck(this, ChunksTailDetails);\n\n    this.chunks = chunks;\n    this.from = from;\n  }\n\n  _createClass(ChunksTailDetails, [{\n    key: \"toString\",\n    value: function toString() {\n      return this.chunks.map(String).join('');\n    } // $FlowFixMe no ideas\n\n  }, {\n    key: \"extend\",\n    value: function extend(tailChunk) {\n      if (!String(tailChunk)) return;\n      if (isString(tailChunk)) tailChunk = new ContinuousTailDetails(String(tailChunk));\n      var lastChunk = this.chunks[this.chunks.length - 1];\n      var extendLast = lastChunk && ( // if stops are same or tail has no stop\n      lastChunk.stop === tailChunk.stop || tailChunk.stop == null) && // if tail chunk goes just after last chunk\n      tailChunk.from === lastChunk.from + lastChunk.toString().length;\n\n      if (tailChunk instanceof ContinuousTailDetails) {\n        // check the ability to extend previous chunk\n        if (extendLast) {\n          // extend previous chunk\n          lastChunk.extend(tailChunk.toString());\n        } else {\n          // append new chunk\n          this.chunks.push(tailChunk);\n        }\n      } else if (tailChunk instanceof ChunksTailDetails) {\n        if (tailChunk.stop == null) {\n          // unwrap floating chunks to parent, keeping `from` pos\n          var firstTailChunk;\n\n          while (tailChunk.chunks.length && tailChunk.chunks[0].stop == null) {\n            firstTailChunk = tailChunk.chunks.shift();\n            firstTailChunk.from += tailChunk.from;\n            this.extend(firstTailChunk);\n          }\n        } // if tail chunk still has value\n\n\n        if (tailChunk.toString()) {\n          // if chunks contains stops, then popup stop to container\n          tailChunk.stop = tailChunk.blockIndex;\n          this.chunks.push(tailChunk);\n        }\n      }\n    }\n  }, {\n    key: \"appendTo\",\n    value: function appendTo(masked) {\n      // $FlowFixMe\n      if (!(masked instanceof IMask.MaskedPattern)) {\n        var tail = new ContinuousTailDetails(this.toString());\n        return tail.appendTo(masked);\n      }\n\n      var details = new ChangeDetails();\n\n      for (var ci = 0; ci < this.chunks.length && !details.skip; ++ci) {\n        var chunk = this.chunks[ci];\n\n        var lastBlockIter = masked._mapPosToBlock(masked.value.length);\n\n        var stop = chunk.stop;\n        var chunkBlock = void 0;\n\n        if (stop != null && ( // if block not found or stop is behind lastBlock\n        !lastBlockIter || lastBlockIter.index <= stop)) {\n          if (chunk instanceof ChunksTailDetails || // for continuous block also check if stop is exist\n          masked._stops.indexOf(stop) >= 0) {\n            details.aggregate(masked._appendPlaceholder(stop));\n          }\n\n          chunkBlock = chunk instanceof ChunksTailDetails && masked._blocks[stop];\n        }\n\n        if (chunkBlock) {\n          var tailDetails = chunkBlock.appendTail(chunk);\n          tailDetails.skip = false; // always ignore skip, it will be set on last\n\n          details.aggregate(tailDetails);\n          masked._value += tailDetails.inserted; // get not inserted chars\n\n          var remainChars = chunk.toString().slice(tailDetails.rawInserted.length);\n          if (remainChars) details.aggregate(masked.append(remainChars, {\n            tail: true\n          }));\n        } else {\n          details.aggregate(masked.append(chunk.toString(), {\n            tail: true\n          }));\n        }\n      }\n\n      return details;\n    }\n  }, {\n    key: \"state\",\n    get: function get() {\n      return {\n        chunks: this.chunks.map(function (c) {\n          return c.state;\n        }),\n        from: this.from,\n        stop: this.stop,\n        blockIndex: this.blockIndex\n      };\n    },\n    set: function set(state) {\n      var chunks = state.chunks,\n          props = _objectWithoutProperties(state, _excluded);\n\n      Object.assign(this, props);\n      this.chunks = chunks.map(function (cstate) {\n        var chunk = \"chunks\" in cstate ? new ChunksTailDetails() : new ContinuousTailDetails(); // $FlowFixMe already checked above\n\n        chunk.state = cstate;\n        return chunk;\n      });\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(beforePos) {\n      if (!this.chunks.length || beforePos != null && this.from >= beforePos) return '';\n      var chunkShiftPos = beforePos != null ? beforePos - this.from : beforePos;\n      var ci = 0;\n\n      while (ci < this.chunks.length) {\n        var chunk = this.chunks[ci];\n        var shiftChar = chunk.unshift(chunkShiftPos);\n\n        if (chunk.toString()) {\n          // chunk still contains value\n          // but not shifted - means no more available chars to shift\n          if (!shiftChar) break;\n          ++ci;\n        } else {\n          // clean if chunk has no value\n          this.chunks.splice(ci, 1);\n        }\n\n        if (shiftChar) return shiftChar;\n      }\n\n      return '';\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      if (!this.chunks.length) return '';\n      var ci = this.chunks.length - 1;\n\n      while (0 <= ci) {\n        var chunk = this.chunks[ci];\n        var shiftChar = chunk.shift();\n\n        if (chunk.toString()) {\n          // chunk still contains value\n          // but not shifted - means no more available chars to shift\n          if (!shiftChar) break;\n          --ci;\n        } else {\n          // clean if chunk has no value\n          this.chunks.splice(ci, 1);\n        }\n\n        if (shiftChar) return shiftChar;\n      }\n\n      return '';\n    }\n  }]);\n\n  return ChunksTailDetails;\n}();\n\nexport { ChunksTailDetails as default };","map":{"version":3,"names":["_","_createClass","a","_classCallCheck","b","_objectWithoutProperties","ChangeDetails","isString","ContinuousTailDetails","IMask","_excluded","ChunksTailDetails","chunks","arguments","length","undefined","from","key","value","toString","map","String","join","extend","tailChunk","lastChunk","extendLast","stop","push","firstTailChunk","shift","blockIndex","appendTo","masked","MaskedPattern","tail","details","ci","skip","chunk","lastBlockIter","_mapPosToBlock","chunkBlock","index","_stops","indexOf","aggregate","_appendPlaceholder","_blocks","tailDetails","appendTail","_value","inserted","remainChars","slice","rawInserted","append","get","c","state","set","props","Object","assign","cstate","unshift","beforePos","chunkShiftPos","shiftChar","splice","default"],"sources":["/home/suraphelm/Projects/demo/Myproject/react/starter/01-starting-setup/node_modules/imask/esm/masked/pattern/chunk-tail-details.js"],"sourcesContent":["import { _ as _createClass, a as _classCallCheck, b as _objectWithoutProperties } from '../../_rollupPluginBabelHelpers-b054ecd2.js';\nimport ChangeDetails from '../../core/change-details.js';\nimport { isString } from '../../core/utils.js';\nimport ContinuousTailDetails from '../../core/continuous-tail-details.js';\nimport IMask from '../../core/holder.js';\n\nvar _excluded = [\"chunks\"];\n\nvar ChunksTailDetails = /*#__PURE__*/function () {\n  /** */\n  function ChunksTailDetails() {\n    var chunks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    _classCallCheck(this, ChunksTailDetails);\n\n    this.chunks = chunks;\n    this.from = from;\n  }\n\n  _createClass(ChunksTailDetails, [{\n    key: \"toString\",\n    value: function toString() {\n      return this.chunks.map(String).join('');\n    } // $FlowFixMe no ideas\n\n  }, {\n    key: \"extend\",\n    value: function extend(tailChunk) {\n      if (!String(tailChunk)) return;\n      if (isString(tailChunk)) tailChunk = new ContinuousTailDetails(String(tailChunk));\n      var lastChunk = this.chunks[this.chunks.length - 1];\n      var extendLast = lastChunk && ( // if stops are same or tail has no stop\n      lastChunk.stop === tailChunk.stop || tailChunk.stop == null) && // if tail chunk goes just after last chunk\n      tailChunk.from === lastChunk.from + lastChunk.toString().length;\n\n      if (tailChunk instanceof ContinuousTailDetails) {\n        // check the ability to extend previous chunk\n        if (extendLast) {\n          // extend previous chunk\n          lastChunk.extend(tailChunk.toString());\n        } else {\n          // append new chunk\n          this.chunks.push(tailChunk);\n        }\n      } else if (tailChunk instanceof ChunksTailDetails) {\n        if (tailChunk.stop == null) {\n          // unwrap floating chunks to parent, keeping `from` pos\n          var firstTailChunk;\n\n          while (tailChunk.chunks.length && tailChunk.chunks[0].stop == null) {\n            firstTailChunk = tailChunk.chunks.shift();\n            firstTailChunk.from += tailChunk.from;\n            this.extend(firstTailChunk);\n          }\n        } // if tail chunk still has value\n\n\n        if (tailChunk.toString()) {\n          // if chunks contains stops, then popup stop to container\n          tailChunk.stop = tailChunk.blockIndex;\n          this.chunks.push(tailChunk);\n        }\n      }\n    }\n  }, {\n    key: \"appendTo\",\n    value: function appendTo(masked) {\n      // $FlowFixMe\n      if (!(masked instanceof IMask.MaskedPattern)) {\n        var tail = new ContinuousTailDetails(this.toString());\n        return tail.appendTo(masked);\n      }\n\n      var details = new ChangeDetails();\n\n      for (var ci = 0; ci < this.chunks.length && !details.skip; ++ci) {\n        var chunk = this.chunks[ci];\n\n        var lastBlockIter = masked._mapPosToBlock(masked.value.length);\n\n        var stop = chunk.stop;\n        var chunkBlock = void 0;\n\n        if (stop != null && ( // if block not found or stop is behind lastBlock\n        !lastBlockIter || lastBlockIter.index <= stop)) {\n          if (chunk instanceof ChunksTailDetails || // for continuous block also check if stop is exist\n          masked._stops.indexOf(stop) >= 0) {\n            details.aggregate(masked._appendPlaceholder(stop));\n          }\n\n          chunkBlock = chunk instanceof ChunksTailDetails && masked._blocks[stop];\n        }\n\n        if (chunkBlock) {\n          var tailDetails = chunkBlock.appendTail(chunk);\n          tailDetails.skip = false; // always ignore skip, it will be set on last\n\n          details.aggregate(tailDetails);\n          masked._value += tailDetails.inserted; // get not inserted chars\n\n          var remainChars = chunk.toString().slice(tailDetails.rawInserted.length);\n          if (remainChars) details.aggregate(masked.append(remainChars, {\n            tail: true\n          }));\n        } else {\n          details.aggregate(masked.append(chunk.toString(), {\n            tail: true\n          }));\n        }\n      }\n      return details;\n    }\n  }, {\n    key: \"state\",\n    get: function get() {\n      return {\n        chunks: this.chunks.map(function (c) {\n          return c.state;\n        }),\n        from: this.from,\n        stop: this.stop,\n        blockIndex: this.blockIndex\n      };\n    },\n    set: function set(state) {\n      var chunks = state.chunks,\n          props = _objectWithoutProperties(state, _excluded);\n\n      Object.assign(this, props);\n      this.chunks = chunks.map(function (cstate) {\n        var chunk = \"chunks\" in cstate ? new ChunksTailDetails() : new ContinuousTailDetails(); // $FlowFixMe already checked above\n\n        chunk.state = cstate;\n        return chunk;\n      });\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(beforePos) {\n      if (!this.chunks.length || beforePos != null && this.from >= beforePos) return '';\n      var chunkShiftPos = beforePos != null ? beforePos - this.from : beforePos;\n      var ci = 0;\n\n      while (ci < this.chunks.length) {\n        var chunk = this.chunks[ci];\n        var shiftChar = chunk.unshift(chunkShiftPos);\n\n        if (chunk.toString()) {\n          // chunk still contains value\n          // but not shifted - means no more available chars to shift\n          if (!shiftChar) break;\n          ++ci;\n        } else {\n          // clean if chunk has no value\n          this.chunks.splice(ci, 1);\n        }\n\n        if (shiftChar) return shiftChar;\n      }\n\n      return '';\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      if (!this.chunks.length) return '';\n      var ci = this.chunks.length - 1;\n\n      while (0 <= ci) {\n        var chunk = this.chunks[ci];\n        var shiftChar = chunk.shift();\n\n        if (chunk.toString()) {\n          // chunk still contains value\n          // but not shifted - means no more available chars to shift\n          if (!shiftChar) break;\n          --ci;\n        } else {\n          // clean if chunk has no value\n          this.chunks.splice(ci, 1);\n        }\n\n        if (shiftChar) return shiftChar;\n      }\n\n      return '';\n    }\n  }]);\n\n  return ChunksTailDetails;\n}();\n\nexport { ChunksTailDetails as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}